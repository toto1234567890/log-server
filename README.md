doc generated by IA, fexible and "universal" TCP socket coming soon..

# Log Server

A high-performance, centralized logging server written in Rust that handles both TCP (Cap'n Proto) and gRPC log messages with ordered file writing and automatic rotation.

## Features

- **Dual Protocol Support**: Accepts log messages via both TCP (Cap'n Proto) and gRPC
- **Ordered Message Writing**: Maintains message sequence integrity using sequence numbers
- **Automatic File Rotation**: Rotates log files based on size with configurable backup count
- **Async Architecture**: Built on Tokio for high-performance concurrent operations
- **Dynamic Batching**: Automatically adjusts batch sizes based on message volume
- **Retry Logic**: Implements retry mechanisms for robust write operations
- **TCP-Only Mode**: Optional flag to run without gRPC server

## Architecture

```
log_server/
├── core/
│   ├── servers.rs      # Main server orchestrator
│   ├── handlers.rs     # Message processing and formatting
│   └── writers.rs      # File writer with ordering and rotation
├── network/
│   ├── tcp_server.rs   # TCP socket server (Cap'n Proto)
│   └── grpc_server.rs  # gRPC server implementation
├── common/
│   ├── config.rs       # Server configuration
│   └── safe_socket.rs  # Safe TCP socket wrapper with framing
├── logger_capnp/
│   └── logger_msg.rs   # Generated Cap'n Proto message schema
├── utils/
│   └── helpers.rs      # Utility functions
└── main.rs             # Entry point
```

## Installation

### Prerequisites

- Rust 1.70 or higher
- Protocol Buffers compiler (for gRPC)
- Cap'n Proto compiler (for TCP messages)

### Build

```bash
cargo build --release
```

## Usage

### Basic Usage

```bash
# Start server with default settings
./log_server

# Start with custom configuration
./log_server --name MyLogServer --host 0.0.0.0 --port 9020 --grpc_port 9021

# Start in TCP-only mode (no gRPC)
./log_server --tcp_only
```

### Command-Line Options

| Option | Default | Description |
|--------|---------|-------------|
| `--name` | `LogServer` | Server instance name |
| `--host` | `127.0.0.1` | Host address to bind to |
| `--port` | `9020` | TCP server port |
| `--grpc_port` | `9021` | gRPC server port |
| `--tcp_only` | `false` | Run TCP server only, disable gRPC |

## Message Format

### Cap'n Proto Schema

The TCP server accepts messages in Cap'n Proto format with the following structure:

```capnp
struct LoggerMsg {
  timestamp @0 :Text;
  hostname @1 :Text;
  loggerName @2 :Text;
  module @3 :Text;
  level @4 :Level;
  filename @5 :Text;
  functionName @6 :Text;
  lineNumber @7 :Text;
  message @8 :Text;
  pathName @9 :Text;
  processId @10 :Text;
  processName @11 :Text;
  threadId @12 :Text;
  threadName @13 :Text;
  serviceName @14 :Text;
  stackTrace @15 :Text;
}

enum Level {
  notset @0;
  debug @1;
  stream @2;
  info @3;
  logon @4;
  logout @5;
  trade @6;
  schedule @7;
  report @8;
  warning @9;
  error @10;
  critical @11;
}
```

### gRPC Protocol

The gRPC server uses the `logservice.proto` definition with a `LogMessage` RPC.

### Output Format

Log messages are formatted as fixed-width columns:

```
<sequence> <timestamp> <hostname> <logger_name> <level> <filename> <function_name> <line_number> <message>
```

Example:
```
0 2025-01-15T10:30:45.123Z myhost app_logger INFO main.py process_data 42 Processing started
```

## Configuration

### Writer Configuration

The log writer can be configured in `writers.rs`:

```rust
pub struct WriterConfig {
    pub initial_batch_size: usize,    // Initial batch size (default: 100)
    pub buffer_size: usize,           // Channel buffer size (default: 1024)
    pub max_retries: usize,           // Write retry attempts (default: 3)
    pub retry_delay_ms: u64,          // Delay between retries (default: 100ms)
    pub max_file_bytes: u64,          // Max file size before rotation (default: 1MB)
    pub backup_count: usize,          // Number of backup files (default: 10)
}
```

### Log File Location

Log files are stored in the `logs/` directory relative to the executable:

- `logs/_main.log` - Current log file
- `logs/_main.log.0` through `logs/_main.log.9` - Rotated backups

## How It Works

### Message Flow

1. **Reception**: Messages arrive via TCP or gRPC
2. **Sequencing**: Each message is assigned a sequence number
3. **Buffering**: Messages are buffered in a BTreeMap ordered by sequence
4. **Batch Processing**: Messages are written in order once a batch is ready
5. **File Rotation**: When file size limit is reached, files are rotated

### Ordered Writing

The server ensures messages are written in strict order:

- Uses sequence numbers to track message order
- Buffers out-of-order messages until gaps are filled
- Dynamically adjusts batch size based on buffer depth
- Guarantees no message reordering in the output file

### TCP Message Framing

TCP messages use a simple framing protocol:
- 4-byte big-endian length prefix
- Variable-length Cap'n Proto packed message

## API

### TCP Client Example

```rust
// Pseudocode for TCP client
let mut stream = TcpStream::connect("127.0.0.1:9020").await?;

// Create Cap'n Proto message
let message = create_log_message(...);

// Serialize with packed format
let packed = capnp::serialize_packed::write_message_to_words(&message);

// Send length prefix + data
let len = packed.len() as u32;
stream.write_all(&len.to_be_bytes()).await?;
stream.write_all(&packed).await?;
```

### gRPC Client Example

```protobuf
service LogService {
  rpc LogMessage(LogRequest) returns (LogResponse);
}

message LogRequest {
  string timestamp = 1;
  string hostname = 2;
  string logger_name = 3;
  int32 level = 4;
  string filename = 5;
  string function_name = 6;
  string line_number = 7;
  string message = 8;
}
```

## Performance Characteristics

- **Async I/O**: Non-blocking operations using Tokio
- **Dynamic Batching**: Adapts to load (10-1000 messages per batch)
- **Connection Pooling**: Handles multiple concurrent clients
- **Buffered Writes**: Minimizes disk I/O operations
- **Retry Logic**: Ensures message durability

## Error Handling

The server handles various error conditions:

- **Connection Errors**: Logs and closes problematic connections
- **Deserialization Errors**: Rejects malformed messages
- **Write Failures**: Retries with exponential backoff
- **Disk Full**: Gracefully handles I/O errors

## Logging

Server operational logs are printed to stdout/stderr:

```
LogServer : starting log server
LogServer : starting server components
LogServer : TCP server listening on 127.0.0.1:9020
LogServer : gRPC server listening on 127.0.0.1:9021
LogServer : all server components started
```

## Development

### Building from Source

```bash
# Debug build
cargo build

# Release build with optimizations
cargo build --release

# Run tests
cargo test

# Check code
cargo clippy
```

### Project Structure

- `core/`: Core business logic (handlers, writers, orchestration)
- `network/`: Network protocol implementations (TCP, gRPC)
- `common/`: Shared utilities and configuration
- `logger_capnp/`: Generated Cap'n Proto code
- `utils/`: Helper functions

## Dependencies

Key dependencies:
- `tokio`: Async runtime
- `capnp`: Cap'n Proto serialization
- `tonic`: gRPC framework
- `bytes`: Byte buffer utilities
- `clap`: Command-line argument parsing
- `chrono`: Timestamp handling

